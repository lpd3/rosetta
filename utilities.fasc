(#Y(si::bytecodes nil nil (1 0 16 1 29) #1=#A(t (133) ("ROS-UTILS" si::select-package ros-utils::printout->string ext::location (defmacro ros-utils::printout->string) (#2=#P"/data/data/org.eql5.android.repl/files/quicklisp/local-projects/rosetta/utilities.lisp" . 65) ext::annotate :lambda-list (&body ros-utils::body) #:g89 #:g88 #:g90 ros-utils::body "STR-STREAM" gensym ros-utils::str with-output-to-string let *standard-output* #Y(ros-utils::printout->string nil nil (24 45 9 24 45 10 26 10 1 5 45 11 10 0 45 12 15 13 19 1 14 45 15 15 16 10 0 6 1 12 15 17 15 18 10 0 6 2 6 1 12 10 1 7 3 6 3 73 43 1 29) #1# #2# 65) t si::fset function "Given a body, returns as a string any 
  printout produced by the body." si::set-documentation ros-utils::broadcast-printout (defmacro ros-utils::broadcast-printout) (#2# . 313) ((&optional (ros-utils::file-name #3="quicklisp/local-projects/rosetta/printout.txt.lisp")) &body ros-utils::body) #:g92 #:g91 #:g93 si::dm-too-few-arguments #:g94 #:g95 #3# ros-utils::file-name si::dm-too-many-arguments "STRING-STREAM" "FILE-STREAM" file-stream string-stream with-open-file (:direction :output :if-does-not-exist :create :if-exists :overwrite) make-broadcast-stream #Y(ros-utils::broadcast-printout nil nil (24 45 29 24 45 30 26 10 1 5 45 31 10 0 76 39 6 13 2 19 1 32 10 0 4 12 10 0 5 51 0 22 45 33 10 0 45 34 10 0 39 13 10 0 4 12 10 0 5 51 0 22 38 3 1 35 45 36 10 3 45 12 10 2 39 6 13 6 19 1 37 15 38 19 1 14 12 15 39 19 1 14 12 46 40 46 41 15 16 10 0 6 1 12 15 42 13 1 13 3 1 43 7 3 12 15 17 15 18 15 44 13 0 10 1 6 3 6 2 6 1 12 10 2 7 3 6 3 6 3 73 43 2 29) #1# #2# 313) "Given an optional filename and body, returns any printout
  produced by the body as a string and 
  writes it to a file." ros-utils::abbrev (defmacro ros-utils::abbrev) (#2# . 1046) (ros-utils::short ros-utils::long) #:g97 #:g96 #:g98 ros-utils::short ros-utils::long defmacro (&rest ros-utils::args) list* quote ros-utils::args #Y(ros-utils::abbrev nil nil (24 45 51 24 45 52 26 10 1 5 45 53 10 0 76 39 6 13 2 19 1 32 10 0 4 12 10 0 5 51 0 22 45 54 10 1 76 39 6 13 3 19 1 32 10 1 4 12 10 1 5 51 1 22 45 55 10 2 39 6 13 4 19 1 37 15 56 13 1 15 57 15 58 15 59 10 0 6 2 12 1 60 6 3 6 4 73 29) #1# #2# 1046) "Given two symbols, the second of which
  is an interned symbol (presumably one
  with a long name) that is assigned 
  an operator, assign the same operator
  to the first (presumably shorter)
  symbol." ros-utils::abbrevs (defmacro ros-utils::abbrevs) (#2# . 1342) (&rest ros-utils::names) #:g100 #:g99 #:g101 ros-utils::names progn ros-utils::pair #Y(nil nil nil (24 45 72 26 15 47 10 0 7 2 73 29) #1# #2# 1342) serapeum::batches mapcar #Y(ros-utils::abbrevs nil nil (24 45 67 24 45 68 26 10 1 5 45 69 10 0 45 70 15 71 1 73 12 13 0 9 2 19 2 74 12 19 2 75 7 2 73 29) #1# #2# 1342) "Given a series of pairs of symbols,
  assign the first symbol in each pair
  the same operator already assigned to
  the second symbol in each pair." ros-utils::mbind (defmacro ros-utils::mbind) (#2# . 1645) #:g103 #:g102 #:g104 multiple-value-bind #Y(ros-utils::mbind nil nil (24 45 81 24 45 82 26 10 1 5 45 83 10 0 45 60 15 84 10 0 7 2 73 29) #1# #2# 1645) ros-utils::dbind (defmacro ros-utils::dbind) (#2# . 1645) #:g106 #:g105 #:g107 destructuring-bind #Y(ros-utils::dbind nil nil (24 45 89 24 45 90 26 10 1 5 45 91 10 0 45 60 15 92 10 0 7 2 73 29) #1# #2# 1645) ros-utils::rationalize (defun ros-utils::rationalize) (#2# . 1726) (ros-utils::x) ros-utils::x (realp ros-utils::x) "RATIONALIZE takes a real argument, not %A %S." type-of si::assert-failure realp rationalp "~F" format ros-utils::nstr length ros-utils::len ros-utils::mantissa ros-utils::i ros-utils::divider ros-utils::sign #\0 char-code ros-utils::zero-code ros-utils::point-seen char ros-utils::c #\+ #\- #\. - ros-utils::val * minusp + 1+ = / #Y(ros-utils::rationalize nil nil (24 45 98 26 38 17 15 99 77 77 15 100 10 0 16 101 12 13 0 19 6 102 10 0 16 103 76 40 -22 10 0 16 104 39 6 10 0 73 38 166 77 15 105 13 0 19 3 106 45 107 10 0 16 108 45 109 8 0 45 110 8 0 45 111 8 1 45 112 8 1 45 113 1 114 16 115 45 116 75 45 117 38 99 13 7 10 4 17 118 45 119 10 0 42 120 3 38 76 42 121 7 8 -1 51 3 38 67 42 122 7 11 20 51 1 38 58 10 0 16 115 12 13 2 19 2 123 45 124 13 7 9 10 19 2 125 12 10 7 16 126 39 8 13 0 19 1 123 38 4 10 0 73 12 19 2 127 51 7 10 2 39 10 13 5 9 10 19 2 125 51 5 43 1 43 1 10 4 16 128 51 4 13 4 13 6 19 2 129 39 -106 13 2 13 5 13 3 19 2 130 12 19 2 125 43 8 29) #1# #2# 1726) "Given a real number, return
  a rational number whose 
  value is identical to the 
  displayed value of the reat 
  (rather than the binary
  approximation.) This is a 
  native CL function, but for some
  reason it does not work as advertised
  in ECL on Android.")) #2# 0) #Y(si::bytecodes nil nil (15 2 15 3 15 4 15 5 19 4 6 15 2 14 7 77 15 8 19 4 6 15 2 1 19 12 14 20 9 1 19 4 21 15 2 15 22 15 23 19 3 24 1 2 73 29) #1# #2# 65) #Y(si::bytecodes nil nil (15 25 15 3 15 26 15 27 19 4 6 15 25 14 7 77 15 28 19 4 6 15 25 1 45 12 14 20 9 2 19 4 21 15 25 15 22 15 46 19 3 24 1 25 73 29) #1# #2# 313) #Y(si::bytecodes nil nil (15 47 15 3 15 48 15 49 19 4 6 15 47 14 7 77 15 50 19 4 6 15 47 1 61 12 14 20 9 3 19 4 21 15 47 15 22 15 62 19 3 24 1 47 73 29) #1# #2# 1046) #Y(si::bytecodes nil nil (15 63 15 3 15 64 15 65 19 4 6 15 63 14 7 77 15 66 19 4 6 15 63 1 76 12 14 20 9 1 19 4 21 15 63 15 22 15 77 19 3 24 1 63 73 29) #1# #2# 1342) #Y(si::bytecodes nil nil (15 78 15 3 15 79 15 80 19 4 6 15 78 14 7 77 15 57 19 4 6 15 78 1 85 12 14 20 9 1 19 4 21 15 86 15 3 15 87 15 88 19 4 6 15 86 14 7 77 15 57 19 4 6 15 86 1 93 12 14 20 9 1 19 4 21 1 86 73 29) #1# #2# 1645) #Y(si::bytecodes nil nil (15 94 15 3 15 95 15 96 19 4 6 15 94 14 7 77 15 97 19 4 6 15 94 1 131 12 19 2 21 15 94 15 22 15 132 19 3 24 1 94 73 29) #1# #2# 1726))
